/*
Домашнее задание по стекам и очередям
*/
/*
Тема: динамические структуры данных — стек Задание.
Есть строка символов, признаком конца, которой является ;. (на своем примере концем строки взял не ;, а сам конец строки '\n', но при необходимости можно заменить на ';' или другой символ)
В строке могут быть фигурные, круглые, квдратные скобки. (от себя еще добавил угловые скобки <>)
Скобки могут быть открывающими и закрывающими.
Необходимо проверить корректность расстановки скобок.
При этом необходимо, чтобы выполнились следующие правила:
1. Каждая открывающая скобка должна иметь справа такую же закрывающую. Обратное также должно быть верно.
2. Открывающие и закрывающие пары скобок разных типов должны быть правильно расположены по от-ношению друг к другу.
■ Пример правильной строки: ({x-y-z}*[x+2y]-(z+4x));
■ Примернеправильнойстроки:([x-y-z}*[x+2y)-{z+4x)].
Если все правила соблюдены выведите информационное сообщение о корректности строки, иначе покажите строку до места возникновения первой ошибки.
*/


#include <iostream>
#include "MyStack.h"

using std::cout;
using std::cin;
using std::endl;
using std::string;

int main_stack() // выполненное задание со стэком - проверено
{
    setlocale(LC_ALL, "ru");
    
    char bracket[2][4]{ '(','[','{','<',
                        ')',']','}','>' };
    MyStack stackBracket{};
    string mathEquation{};
    int Menu{};
    int exitIndex{-1}; // для возможности выхода из вложенных циклов сразу сразу после нахождения ошибки и сохранения индекса где обнаружена ошибка
    do
    {
        cout << "Меню проверки на корректность открытия и закрытия скобок в арифметическом выражении" << endl;
        cout << "1) Проверить" << endl;
        cout << "0) Выход" << endl;
        cin >> Menu;
        if (Menu)
        {
            stackBracket.Clear();
            cout << "Введите матиматическое выражение с открытием и закрытием скобок: ";
            cin >> mathEquation;
            for (int s = 0; s < mathEquation.size(); s++)
            {
                for (int i = 0; i < 4; i++) // перебор массива открытых скобок разных типов
                {
                    if (mathEquation[s] == bracket[0][i]) // сравнение с открывающими скобками и если находит, то кладем в стэк
                    {
                        stackBracket.Push(mathEquation[s]);
                        break;
                    }
                    else if (mathEquation[s] == bracket[1][i]) // сравнение с закрывающими скобками и если находим то вытаскиваем из стэка открывающую скобку и делаем сравнение на соотвествие типу
                    {
                        if (bracket[0][i] != stackBracket.Pop()) // если несовпадает тип скобки, то завершаем сравнение и выводим индекс строки где была обнаружено не соотвествие правилу открытия и закрытия скобок
                            exitIndex = s;
                        break;
                    }
                }
                if (exitIndex >= 0)
                {
                    break;
                }
            }
            if (exitIndex < 0 && stackBracket.IsEmpty())
            {
                cout << "Математическое уравнение: " << mathEquation << " Составлено верно!" << endl;
            }
            else if (exitIndex >=0)
            {
                cout << "Математическое уравнение: \"" << mathEquation << "\" имеет ошибку в символе под номером - " << exitIndex + 1 << endl;
                cout << "Выводим уравнение до места возникновения ошибки: " << mathEquation.substr(0, exitIndex+1) << endl;
            }
            else
            {
                cout << "Уравнение не имеет следующие закрывающие скобки: ";
                while (!stackBracket.IsEmpty())
                {
                    char bra = stackBracket.Pop();
                    for (int i = 0; i < 4; i++)
                    {
                        if (bra == bracket[0][i])
                        {
                            cout << bracket[1][i] << " ";
                            break;
                        }
                    }
                }
                cout << endl;
            }
        }
        stackBracket.Clear(); // очистка стэка на случай если он дальше будет использоваться, но перед этим забудут его освободить
    } while (Menu != 0);
    

    return 0;
}

int main()
{
    setlocale(LC_ALL,"ru");



    return 0;
}
